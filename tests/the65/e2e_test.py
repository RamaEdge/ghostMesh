#!/usr/bin/env python3
"""
THE-65 End-to-End Integration Test
Multi-device telemetry simulation with complete data flow validation

This script tests the complete GhostMesh pipeline:
1. Start all services via docker-compose
2. Publish multi-device telemetry data
3. Verify anomaly detection generates alerts
4. Validate policy engine processes alerts
5. Check dashboard receives real-time data
"""

import json
import time
import subprocess
import sys
import os
from datetime import datetime
from typing import Dict, List, Any


def run_command(cmd: str, timeout: int = 30) -> subprocess.CompletedProcess:
    """Run a shell command with timeout and return result."""
    print(f"$ {cmd}")
    try:
        result = subprocess.run(
            cmd, 
            shell=True, 
            capture_output=True, 
            text=True, 
            timeout=timeout
        )
        return result
    except subprocess.TimeoutExpired:
        print(f"[ERROR] Command timed out after {timeout}s: {cmd}")
        return subprocess.CompletedProcess(cmd, 1, "", "Timeout")


def check_services_healthy() -> bool:
    """Check if all GhostMesh services are running and healthy."""
    print("Checking service health...")
    
    services = [
        "ghostmesh-mosquitto",
        "ghostmesh-mock-opcua", 
        "ghostmesh-gateway",
        "ghostmesh-detector",
        "ghostmesh-policy",
        "ghostmesh-dashboard"
    ]
    
    for service in services:
        result = run_command(f"podman ps --filter name={service} --format '{{{{.Status}}}}'")
        if result.returncode != 0 or "Up" not in result.stdout:
            print(f"[ERROR] Service {service} is not running")
            return False
        print(f"✓ {service} is running")
    
    return True


def publish_telemetry_batch(batch_size: int = 10) -> None:
    """Publish telemetry data for multiple devices and signals."""
    print(f"Publishing telemetry batch (size: {batch_size})...")
    
    # Multi-device configuration
    assets = ["Press01", "Press02", "Conveyor01", "Valve03", "Sensor05"]
    signals = ["Temperature", "Pressure", "Speed", "Vibration"]
    
    published_count = 0
    
    for asset in assets:
        for signal in signals:
            for i in range(batch_size):
                # Generate realistic telemetry values with some variation
                if signal == "Temperature":
                    base_value = 25.0
                    variation = (hash(asset) % 10) * 0.5
                    value = base_value + variation + (i * 0.3) + (i % 3) * 1.2
                elif signal == "Pressure":
                    base_value = 10.0
                    variation = (hash(asset) % 5) * 0.8
                    value = base_value + variation + (i * 0.2) + (i % 2) * 0.9
                elif signal == "Speed":
                    base_value = 50.0
                    variation = (hash(asset) % 8) * 1.0
                    value = base_value + variation + (i * 0.4) + (i % 4) * 2.1
                else:  # Vibration
                    base_value = 0.5
                    variation = (hash(asset) % 3) * 0.2
                    value = base_value + variation + (i * 0.1) + (i % 5) * 0.3
                
                # Create telemetry payload following GhostMesh schema
                payload = {
                    "assetId": asset,
                    "line": "Line1",
                    "signal": signal,
                    "value": round(value, 2),
                    "unit": "C" if signal == "Temperature" else "bar" if signal == "Pressure" else "rpm" if signal == "Speed" else "mm/s",
                    "ts": datetime.utcnow().isoformat() + "Z",
                    "quality": "good",
                    "source": "simulator",
                    "seq": published_count
                }
                
                # Publish to MQTT via mosquitto container
                topic = f"factory/Line1/{asset}/{signal}"
                payload_json = json.dumps(payload)
                
                cmd = f"podman exec ghostmesh-mosquitto mosquitto_pub -h localhost -t '{topic}' -m '{payload_json}' -q 1"
                result = run_command(cmd, timeout=10)
                
                if result.returncode == 0:
                    published_count += 1
                    print(f"  ✓ Published: {topic} = {value}")
                else:
                    print(f"  ✗ Failed to publish: {topic}")
                
                # Small delay between publishes
                time.sleep(0.1)
    
    print(f"Published {published_count} telemetry messages")


def check_alerts(timeout: int = 60) -> List[Dict[str, Any]]:
    """Check for alerts generated by anomaly detector."""
    print(f"Checking for alerts (timeout: {timeout}s)...")
    
    alerts_found = []
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        # Subscribe to alerts topic with timeout
        cmd = "podman exec ghostmesh-mosquitto mosquitto_sub -h localhost -t 'alerts/+/+' -C 1 -v"
        result = run_command(cmd, timeout=5)
        
        if result.returncode == 0 and result.stdout.strip():
            try:
                # Parse alert message
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if line.startswith('alerts/'):
                        parts = line.split(' ', 1)
                        if len(parts) == 2:
                            topic = parts[0]
                            payload_str = parts[1]
                            alert_data = json.loads(payload_str)
                            alert_data['topic'] = topic
                            alerts_found.append(alert_data)
                            print(f"  ✓ Alert found: {topic} - {alert_data.get('severity', 'unknown')} severity")
            except json.JSONDecodeError as e:
                print(f"  ✗ Failed to parse alert: {e}")
        
        time.sleep(2)
    
    print(f"Found {len(alerts_found)} alerts")
    return alerts_found


def check_audit_events(timeout: int = 30) -> List[Dict[str, Any]]:
    """Check for audit events from policy engine."""
    print(f"Checking for audit events (timeout: {timeout}s)...")
    
    audit_events = []
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        cmd = "podman exec ghostmesh-mosquitto mosquitto_sub -h localhost -t 'audit/actions' -C 1 -v"
        result = run_command(cmd, timeout=5)
        
        if result.returncode == 0 and result.stdout.strip():
            try:
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if 'audit/actions' in line:
                        parts = line.split(' ', 1)
                        if len(parts) == 2:
                            audit_data = json.loads(parts[1])
                            audit_events.append(audit_data)
                            print(f"  ✓ Audit event: {audit_data.get('action', 'unknown')} on {audit_data.get('assetId', 'unknown')}")
            except json.JSONDecodeError as e:
                print(f"  ✗ Failed to parse audit event: {e}")
        
        time.sleep(2)
    
    print(f"Found {len(audit_events)} audit events")
    return audit_events


def test_control_commands() -> bool:
    """Test control command publishing and policy engine response."""
    print("Testing control commands...")
    
    # Test isolate command
    control_payload = {
        "assetId": "Press01",
        "command": "isolate",
        "reason": "e2e_test",
        "refAlertId": "test-alert-001",
        "ts": datetime.utcnow().isoformat() + "Z"
    }
    
    topic = "control/Press01/isolate"
    payload_json = json.dumps(control_payload)
    
    cmd = f"podman exec ghostmesh-mosquitto mosquitto_pub -h localhost -t '{topic}' -m '{payload_json}' -q 1"
    result = run_command(cmd, timeout=10)
    
    if result.returncode == 0:
        print(f"  ✓ Control command published: {topic}")
        return True
    else:
        print(f"  ✗ Failed to publish control command: {topic}")
        return False


def validate_message_schemas(alerts: List[Dict], audit_events: List[Dict]) -> bool:
    """Validate that messages follow the correct schemas."""
    print("Validating message schemas...")
    
    # Validate alert schema
    required_alert_fields = ['alertId', 'assetId', 'signal', 'severity', 'reason', 'current', 'ts']
    for alert in alerts:
        for field in required_alert_fields:
            if field not in alert:
                print(f"  ✗ Alert missing required field: {field}")
                return False
        print(f"  ✓ Alert schema valid: {alert['alertId']}")
    
    # Validate audit schema
    required_audit_fields = ['actionId', 'assetId', 'action', 'method', 'result', 'ts']
    for audit in audit_events:
        for field in required_audit_fields:
            if field not in audit:
                print(f"  ✗ Audit event missing required field: {field}")
                return False
        print(f"  ✓ Audit schema valid: {audit['actionId']}")
    
    return True


def main():
    """Main end-to-end test execution."""
    print("=" * 60)
    print("THE-65: GhostMesh End-to-End Integration Test")
    print("=" * 60)
    
    # Step 1: Start services
    print("\n1. Starting GhostMesh services...")
    result = run_command("make start", timeout=120)
    if result.returncode != 0:
        print("[ERROR] Failed to start services")
        print(f"Error: {result.stderr}")
        sys.exit(1)
    
    # Step 2: Wait for services to stabilize
    print("\n2. Waiting for services to stabilize...")
    time.sleep(10)
    
    # Step 3: Check service health
    print("\n3. Checking service health...")
    if not check_services_healthy():
        print("[ERROR] Not all services are healthy")
        sys.exit(1)
    
    # Step 4: Publish telemetry data
    print("\n4. Publishing multi-device telemetry...")
    publish_telemetry_batch(batch_size=8)
    
    # Step 5: Check for alerts
    print("\n5. Checking for anomaly alerts...")
    alerts = check_alerts(timeout=60)
    
    # Step 6: Test control commands
    print("\n6. Testing control commands...")
    control_success = test_control_commands()
    
    # Step 7: Check for audit events
    print("\n7. Checking for audit events...")
    audit_events = check_audit_events(timeout=30)
    
    # Step 8: Validate schemas
    print("\n8. Validating message schemas...")
    schema_valid = validate_message_schemas(alerts, audit_events)
    
    # Step 9: Summary and results
    print("\n" + "=" * 60)
    print("TEST RESULTS SUMMARY")
    print("=" * 60)
    
    print(f"Services Health: {'✓ PASS' if check_services_healthy() else '✗ FAIL'}")
    print(f"Telemetry Published: ✓ PASS")
    print(f"Alerts Generated: {'✓ PASS' if len(alerts) > 0 else '⚠ WARN (no alerts)'}")
    print(f"Control Commands: {'✓ PASS' if control_success else '✗ FAIL'}")
    print(f"Audit Events: {'✓ PASS' if len(audit_events) > 0 else '⚠ WARN (no audit events)'}")
    print(f"Schema Validation: {'✓ PASS' if schema_valid else '✗ FAIL'}")
    
    # Overall result
    if len(alerts) > 0 and control_success and schema_valid:
        print("\n🎉 END-TO-END TEST: ✓ PASS")
        print("Complete data flow verified: Telemetry → Alerts → Control → Audit")
        sys.exit(0)
    else:
        print("\n❌ END-TO-END TEST: ✗ FAIL")
        print("Some components of the data flow failed")
        sys.exit(1)


if __name__ == "__main__":
    main()